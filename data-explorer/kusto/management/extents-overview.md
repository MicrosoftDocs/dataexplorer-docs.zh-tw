---
title: " (資料分區) 的範圍-Azure 資料總管"
description: 本文描述 Azure 資料總管中 (資料分區) 的範圍。
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/13/2020
ms.openlocfilehash: c1ed0de6f638828abe120caffcb5e14517f09a02
ms.sourcegitcommit: 898f67b83ae8cf55e93ce172a6fd3473b7c1c094
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/21/2020
ms.locfileid: "92342734"
---
# <a name="extents-data-shards"></a>範圍 (資料分區) 

## <a name="overview"></a>概觀

Kusto 的設計是為了支援具有大量記錄 (資料列) 和大量資料的資料表。 為了處理這類大型資料表，每個資料表的資料會分成較小的「平板電腦」（稱為 **資料分區** 或 **範圍** ） (這兩個詞彙都是同義) 。 所有資料表範圍的聯集都會保存資料表的資料。 個別範圍會保持小於單一節點的容量，而且範圍會散佈在叢集的節點上，以達成相應放大。

範圍就像是迷你資料表的型別。 它包含資料和中繼資料，以及與其資料相關聯的選擇性標記，例如其建立時間和選用標記。 此外，此範圍通常會保留可讓 Kusto 有效率地查詢資料的資訊。
例如，如果資料行資料是經過編碼的，則為範圍中資料的每個資料行的索引，以及編碼字典。 因此，資料表的資料是資料表範圍中所有資料的聯集。

範圍是不可變的，且永遠不會修改。 它可能只會被查詢、重新指派給不同的節點，或從資料表中卸載。 藉由建立一或多個新的範圍，並以新的範圍以交易方式交換舊的範圍，進行資料修改。

範圍會保存實體排列在資料行中的記錄集合。
這項技術稱為單 **欄式存放區**。 它能夠有效率地編碼和壓縮資料，因為相同資料行中的不同值通常會彼此「相似」。 它也可讓您更有效率地查詢大型資料範圍，因為只需要載入查詢所使用的資料行。 就內部而言，範圍中的每個資料行都會細分成區段，並將區段分成區塊。 這是查詢不可觀察的部門，並讓 Kusto 優化資料行壓縮和索引。

為了維持查詢效率，較小的範圍會合並成較大的範圍。
合併會根據設定的 [合併原則](mergepolicy.md) 和 [分區化原則](shardingpolicy.md)，自動以背景進程的方式完成。
合併範圍可減少擁有大量追蹤的管理額外負荷。更重要的是，它可讓 Kusto 優化其索引並改善壓縮。

範圍合併會在某個範圍達到特定限制（例如大小）之後停止，例如，由於超過特定時間點，合併會減少，而不會提高效率。

當資料表上定義了 [資料分割原則](partitioningpolicy.md) 時，範圍會在建立之後，透過另一個背景進程 (後置內嵌) 。 此程式會 reingests 來源範圍中的資料，並建立 *同質* 範圍，其中資料表的資料 *分割索引鍵* 資料行的值全都屬於相同的資料分割。 如果原則包含 *雜湊分割索引鍵*，則屬於相同資料分割的所有同質範圍都會指派給叢集中的相同資料節點。

> [!NOTE]
> 範圍層級的作業（例如合併或改變範圍標籤）不會修改現有的範圍。
> 相反地，會根據現有的來源範圍，在這些作業中建立新的範圍。 新的範圍會將其 forefathers 取代為單一交易。

常見的範圍生命週期為：

1. 範圍是 **由內嵌作業** 所建立。
1. 範圍會與其他範圍合併。 當合併的範圍很少時，Kusto 實際上會在其上執行內嵌程式，稱為「 **重建**」。 一旦範圍達到特定大小，就只會針對索引進行合併。 未修改儲存體中的範圍資料成品。
1. 合併的範圍 (可能會追蹤其歷程至其他合併範圍，因此) 最終會因為保留原則而下降。 
   當您卸載範圍時，根據 (舊版 x 小時/天) 的時間，就會在計算中使用合併的最新範圍內的建立日期。

## <a name="extent-creation-time"></a>範圍建立時間

每個範圍的其中一個重要資訊是建立時間。 這次用於：

1. 稍早建立的**保留**範圍將會提早卸載。
1. 快**取-最近建立的範圍**將會保留在[熱](cachepolicy.md)快取中) 
1. **取樣** -使用查詢作業（例如）時，最優先使用最新的範圍 `take`

事實上，Kusto 會追蹤每個範圍的兩個 `datetime` 值： `MinCreatedOn` 和 `MaxCreatedOn` 。
一開始，這兩個值是相同的。 當範圍與其他範圍合併時，新的值會根據合併範圍的原始最小值和最大值而定。

一般來說，範圍的建立時間是根據內嵌範圍中資料的時間來設定。 用戶端可以選擇性地覆寫延伸區的建立時間，方法是在內嵌 [屬性](../../ingestion-properties.md)中提供替代的建立時間。
覆寫很有用，例如基於保留目的，如果用戶端想要 reingest 資料，而不想讓它看起來像是遲到的一樣。

## <a name="extent-tagging"></a>範圍標記

Kusto 支援將多個選擇性的 *範圍* 標籤附加至範圍中，做為其中繼資料的一部分。 範圍標記 (或單純 *標記*) ，是與範圍相關聯的字串。 您可以使用 [ [顯示範圍](./show-extents.md) ] 命令來查看與範圍相關聯的標記，並使用 [範圍標籤 ( # B1 ](../query/extenttagsfunction.md) 函數來查看與範圍中的記錄相關聯的標記。
範圍標籤可以用來有效率地描述範圍內所有資料通用的屬性。
例如，您可以在內嵌期間新增範圍標籤，以指出內嵌資料的來源，並在稍後使用該標記。 由於範圍會描述資料，當兩個或多個合併時，其相關聯的標記也會合並。 產生的範圍標籤將會是這些合併範圍之所有標記的聯集。

Kusto 會指派特殊意義給所有範圍標籤，其值的格式為*前置**詞，其中*的*前置*詞為下列其中一個：

* `drop-by:`
* `ingest-by:`

### <a name="drop-by-extent-tags"></a>' drop： ' 範圍標籤

以前置詞開頭的標記 `drop-by:` 可以用來控制要合併的其他範圍。 具有指定標記的範圍 `drop-by:` 可以合併在一起，但不會與其他範圍合併。 然後，您可以發出命令，根據其標記來捨棄範圍 `drop-by:` 。

例如：

```kusto
.ingest ... with @'{"tags":"[\"drop-by:2016-02-17\"]"}'

.drop extents <| .show table MyTable extents where tags has "drop-by:2016-02-17" 
```

#### <a name="performance-notes"></a>效能注意事項

* 請勿過度過度用 `drop-by` 標記。 以上述方式卸載資料是針對很少發生的事件。 它不是用來取代記錄層級資料，而是依賴以這種方式標記的資料很龐大的事實。 嘗試為每筆記錄或少量記錄提供不同的標記，可能會對效能造成嚴重的影響。
* 如果在 `drop-by` 資料內嵌之後的一段時間內不需要標記，我們建議您 [捨棄標記](#drop-by-extent-tags)。

### <a name="ingest-by-extent-tags"></a>' 內嵌： ' 範圍標籤

以前置詞開頭的標記 `ingest-by:` 可以用來確保資料只會內嵌一次。 **`ingestIfNotExists`** 如果已有具有此特定標記的範圍，您可以發出屬性命令來防止資料內嵌 `ingest-by:` 。
和的值 `tags` `ingestIfNotExists` 都是序列化為 JSON 的字串陣列。

下列範例只會內嵌一次資料。 第二個和第三個命令不會執行任何動作：

```kusto
.ingest ... with (tags = '["ingest-by:2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]', tags = '["ingest-by:2016-02-17"]')
```

> [!NOTE]
> 一般而言，內嵌命令可能會同時包含 `ingest-by:` 標記和 `ingestIfNotExists` 屬性，並設定為相同的值，如上面的第三個命令所示。

#### <a name="performance-notes"></a>效能注意事項

* `ingest-by`不建議使用過度使用標記。
如果已知管線饋送 Kusto 有資料重複問題，建議您盡可能解決這些重複問題，然後再將資料擷取至 Kusto。 此外， `ingest-by` 只有當內嵌至 Kusto 的部分可能會產生重複專案時，才在 Kusto 中使用標籤 (例如，有一種重試機制可與已進行中的內嵌呼叫重迭) 。 嘗試為每個內嵌呼叫設定唯一的 `ingest-by` 標記，可能會對效能造成嚴重的影響。
* 如果在資料內嵌之後的一段時間內不需要這類標記，我們建議您 [捨棄範圍](drop-extent-tags.md)標籤。
