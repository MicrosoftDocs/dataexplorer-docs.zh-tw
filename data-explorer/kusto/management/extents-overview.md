---
title: 範圍（資料分區）-Azure 資料總管
description: 本文說明 Azure 資料總管中的範圍（資料分區）。
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/13/2020
ms.openlocfilehash: 6c7910a222227dbb6b22e1fc4f0f4136897a0ef9
ms.sourcegitcommit: be1bbd62040ef83c08e800215443ffee21cb4219
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/10/2020
ms.locfileid: "84665107"
---
# <a name="extents-data-shards"></a>範圍（資料分區）

## <a name="overview"></a>概觀

Kusto 的建立是為了支援具有大量記錄（資料列）和大量資料的資料表。 為了處理這類大型資料表，每個資料表的資料會分成較小的「平板電腦」，稱為**資料分區**或**範圍**（這兩個詞彙是同義的）。 所有資料表範圍的聯集都會保留資料表的資料。 個別的範圍會保持小於單一節點的容量，而範圍則會分散在叢集的節點上，以達到相應放大。

範圍就像是一種迷你資料表。 它包含資料和中繼資料，以及與其資料相關聯的選擇性標記等資訊。 此外，範圍通常會保存可讓 Kusto 有效率地查詢資料的資訊。
例如，如果資料行資料已編碼，則為範圍中的每個資料行的索引和編碼字典。 因此，資料表的資料就是資料表範圍中所有資料的聯集。

範圍是不可變的，而且永遠無法修改。 它可能只會查詢、重新指派至不同的節點，或卸載到資料表之外。 資料修改會藉由建立一或多個新的範圍，並以新的範圍以交易方式交換舊範圍來進行。

範圍會保存實際排列在資料行中的記錄集合。
這項技術稱為單**欄式存放區**。 它可以有效率地編碼和壓縮資料，因為相同資料行中的不同值通常會彼此「相似」。 它也可以更有效率地查詢大型資料範圍，因為只需要載入查詢所使用的資料行。 就內部而言，範圍中的每個資料行都會細分為區段，而區段會分成區塊。 這種除法無法觀察查詢，而且可讓 Kusto 優化資料行壓縮和索引。

為了維持查詢效率，較小的範圍會合並成較大的範圍。
合併會根據已設定的[合併原則](mergepolicy.md)和[分區化原則](shardingpolicy.md)，自動以背景進程的方式完成。
合併範圍可減少擁有大量追蹤範圍的管理負荷。更重要的是，它允許 Kusto 優化其索引並改善壓縮。

範圍合併會在某個範圍達到特定限制（例如大小）後停止，而不是在某個時間點之後，合併會減少，而不是提高效率。

在資料表上定義[資料分割原則](partitioningpolicy.md)時，範圍會在建立後完成另一個背景進程（後置內嵌）。 此程式會從來源範圍 reingests 資料，並建立*同質*範圍，其中是資料表的分割區索引*鍵*的資料行值全都屬於相同的資料分割。 如果原則包含*雜湊資料分割索引鍵*，屬於相同分割區的所有同質範圍都會指派給叢集中的相同資料節點。

> [!NOTE]
> 範圍層級的作業，例如合併或更改範圍標籤，不會修改現有的範圍。
> 相反地，會根據現有的來源範圍，在這些作業中建立新的範圍。 新的範圍會取代其在單一交易中的 forefathers。

常見的範圍生命週期為：

1. 範圍是**由內嵌作業**所建立。
1. 範圍會與其他範圍合併。 當合併的範圍很少時，Kusto 實際上會在其上執行內嵌進程，稱為**rebuild**。 一旦範圍達到特定大小，就只會針對索引進行合併。 儲存體中的範圍資料成品不會修改。
1. 合併的範圍（可能是追蹤其歷程到其他合併範圍等）最終會因為保留原則而卸載。 
   當範圍根據時間（較舊的 x 小時/天）卸載時，會在計算中使用合併的最新範圍內的建立日期。

## <a name="extent-creation-time"></a>範圍建立時間

每個範圍的一項更重要的資訊就是建立時間。 這段時間用於：

1. **保留期**-稍早建立的範圍將會稍早卸載。
1. 快**取-最近建立的範圍**會保留在[熱](cachepolicy.md)快取中）
1. **取樣**-使用諸如之類的查詢作業時最新的範圍`take`

事實上，Kusto 會追蹤每個範圍的兩個 `datetime` 值： `MinCreatedOn` 和 `MaxCreatedOn` 。
一開始，這兩個值是相同的。 當範圍與其他範圍合併時，新的值會根據合併範圍的原始最小值和最大值來進行。

通常會根據範圍中的資料內嵌時間來設定範圍的建立時間。 用戶端可以選擇性地覆寫範圍的建立時間，方法是在內嵌[屬性](../../ingestion-properties.md)中提供替代的建立時間。
如果用戶端想要 reingest 資料，而不想讓它看起來像抵達晚期，覆寫就很有用，例如基於保留目的。

## <a name="extent-tagging"></a>範圍標記

Kusto 支援將多個選擇性*範圍標記*附加至範圍內，做為其中繼資料的一部分。 範圍標記（或單純*標記*）是與範圍相關聯的字串。 您可以使用[. 顯示範圍](extents-commands.md#show-extents)命令來查看與範圍相關聯的標記，以及[範圍標記（）函式](../query/extenttagsfunction.md)來查看與範圍中的記錄相關聯的標記。
範圍標籤可以用來有效率地描述範圍中所有資料通用的屬性。
例如，您可以在內嵌期間加入範圍標籤，這會指出內嵌資料的來源，並在稍後使用該標記。 由於範圍會描述資料，因此當兩個或多個合併時，其相關聯的標記也會合並。 產生的範圍標記會是那些合併範圍之所有標記的聯集。

Kusto 會將特殊意義指派給其值具有格式*首碼**尾碼*的所有範圍標籤，其中的*前置*詞為下列其中一個：

* `drop-by:`
* `ingest-by:`

### <a name="drop-by-extent-tags"></a>' drop： ' 範圍標記

開頭為前置詞的標記 `drop-by:` 可用來控制要合併的其他範圍。 具有指定標記的範圍 `drop-by:` 可以合併在一起，但不會與其他範圍合併。 接著，您可以發出命令，根據其標記來捨棄範圍 `drop-by:` 。

例如：

```kusto
.ingest ... with @'{"tags":"[\"drop-by:2016-02-17\"]"}'

.drop extents <| .show table MyTable extents where tags has "drop-by:2016-02-17" 
```

#### <a name="performance-notes"></a>效能注意事項

* 不要過度用 `drop-by` 標記。 以上述方式卸載資料適用于很少發生的事件。 它不是用來取代記錄層級的資料，而是依賴以這種方式標記的資料很龐大的事實。 嘗試為每一筆記錄或少量記錄提供不同的標記，可能會對效能造成嚴重的影響。
* 如果在 `drop-by` 內嵌資料之後的一段時間內不需要標記，我們建議您卸載[標記](extents-commands.md#drop-extent-tags)。

### <a name="ingest-by-extent-tags"></a>' 內嵌： ' 範圍標記

開頭為前置詞的標記 `ingest-by:` 可用於確保資料只會內嵌一次。 **`ingestIfNotExists`** 如果已經有此特定標記的範圍，您可以發出屬性命令來防止資料內嵌 `ingest-by:` 。
和的值 `tags` `ingestIfNotExists` 都是字串陣列，序列化為 JSON。

下列範例只會內嵌資料一次。 第二個和第三個命令不會執行任何動作：

```kusto
.ingest ... with (tags = '["ingest-by:2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]', tags = '["ingest-by:2016-02-17"]')
```

> [!NOTE]
> 一般而言，內嵌命令可能會同時包含標籤 `ingest-by:` 和 `ingestIfNotExists` 屬性（property），並將其設定為相同的值，如上面的第3個命令所示。

#### <a name="performance-notes"></a>效能注意事項

* `ingest-by`不建議使用超標記。
如果已知管線饋送 Kusto 有資料重複問題，我們建議您盡可能解決這些重複問題，再將資料內嵌到 Kusto。 此外， `ingest-by` 只有當內嵌至 Kusto 的元件可能會產生重複專案時，才使用 Kusto 中的標籤（例如，有可能會與已在進行中的內嵌呼叫重迭的重試機制）。 嘗試為 `ingest-by` 每個內嵌呼叫設定唯一標記，可能會對效能造成嚴重的影響。
* 如果在內嵌資料之後的一段時間內不需要這類標記，建議您卸載[標記](extents-commands.md#drop-extent-tags)。
 
