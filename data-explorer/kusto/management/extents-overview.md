---
title: 範圍（資料分區）-Azure 資料總管 |Microsoft Docs
description: 本文說明 Azure 資料總管中的範圍（資料分區）。
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/13/2020
ms.openlocfilehash: 35ba47fde9c1bdd5adf0f57ed40d028f4dc520c2
ms.sourcegitcommit: 39b04c97e9ff43052cdeb7be7422072d2b21725e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/12/2020
ms.locfileid: "83227752"
---
# <a name="extents-data-shards"></a>範圍（資料分區）

## <a name="overview"></a>概觀

Kusto 的建立是為了支援具有大量記錄（資料列）和大量資料的資料表。 為了能夠處理這類大型資料表，Kusto 會將每個資料表的資料分割成較小的「平板電腦」，稱為**資料分區**或**範圍**（這兩個詞彙是同義字），因此所有資料表範圍的聯集都會保留資料表的資料。 然後，個別的範圍會保持小於單一節點的容量，而範圍則會散佈在叢集的節點上，以達到相應放大。 

其中一個可將範圍視為一種迷你資料表。 範圍會保存中繼資料（指出範圍中資料的架構，以及其他資訊，例如其建立時間和與範圍中的資料相關聯的選擇性標記）和資料。 此外，範圍通常會保存可讓 Kusto 有效率地查詢資料的資訊，例如範圍中每個資料行的索引，以及如果資料行資料已編碼，則為編碼字典。 因此，資料表的資料是資料表範圍中所有資料的聯集。

範圍是*不可變*的。 建立之後，永遠不會修改範圍，而且範圍只能查詢、重新指派至不同的節點，或從資料表卸載。 資料修改會藉由建立一或多個新的範圍，以及交易交換具有新範圍的舊範圍來進行。

範圍會保存記錄的集合，並以資料行實際排列。
這項技術（稱為單**欄式存放區**）讓您能夠有效率地編碼和壓縮資料（因為相同的資料行中的不同值通常會彼此「相似」），並可更有效率地查詢大型資料範圍，因為只需要載入查詢所使用的資料行。 就內部而言，範圍中的每個資料行都會細分為區段，而區段會分成區塊。 這種除法（查詢無法觀察）可讓 Kusto 優化資料行壓縮和編制索引。

為了維持查詢效率，較小的範圍會合並成較大的範圍。
根據已設定的[合併原則](mergepolicy.md)和[分區化原則](shardingpolicy.md)，Kusto 會自動以背景進程的方式執行此作業。
合併範圍會同時減少擁有大量追蹤的管理負荷，但更重要的是，它允許 Kusto 優化其索引並改善壓縮。 範圍合併會在某個範圍達到特定限制（例如大小）時停止，而不限於特定的時間點合併範圍，而不會增加效率。

在資料表上定義[資料分割原則](partitioningpolicy.md)時，範圍會在建立後完成另一個背景進程（後置內嵌）。 此程式會重新內嵌來源範圍中的資料，並建立*同質*範圍，其中是資料表之分割區索引*鍵*的資料行值全都屬於相同的資料分割。 如果原則包含*雜湊分割*區索引鍵，則會保證屬於相同資料分割的所有同質範圍都會指派給叢集中的相同資料節點。

> [!NOTE]
> 範圍層級的作業，例如合併、改變範圍標記等，請勿修改現有的範圍。
> 相反地，新的範圍會根據現有的來源範圍在這些作業中建立，而這些新的範圍會取代其在單一交易中的 forefathers。

範圍的常見「生命週期」如下：

1. 範圍是**由內嵌作業**所建立。
2. 範圍會與其他範圍合併。 當合併的範圍很少時，Kusto 實際上會對它們執行內嵌程式（這稱為**rebuild**）。 一旦範圍達到特定大小，就只會針對索引進行合併，而不會修改儲存區中的資料構件。
3. 合併的範圍（可能是追蹤其歷程到其他合併範圍等）最終會因為保留原則而遭到捨棄。 當範圍根據時間（較舊的 x 小時/天）卸載時，會將合併中最新範圍內的建立日期納入計算。

## <a name="extent-creation-time"></a>範圍建立時間

每個範圍的一項更重要的資訊就是建立時間。 這段時間是由 Kusto 用於：

1. 保留期（稍早建立的範圍會稍早卸載）。
2. 快取（最近建立的範圍會保留在[熱緩存](cachepolicy.md)中）。
3. 取樣（使用之類的查詢作業時 `take` ，最新的範圍會較優先）。

事實上，Kusto 會追蹤每個範圍的兩個 `datetime` 值： `MinCreatedOn` 和 `MaxCreatedOn` 。
這些值的開頭都相同，但當範圍與其他範圍合併時，產生的範圍值會分別是所有合併範圍的值。

通常會根據範圍中的資料內嵌時間來設定範圍的建立時間。 用戶端可以選擇性地覆寫範圍的建立時間，其方式是在內嵌[屬性](../../ingestion-properties.md)中提供替代的建立時間（例如，如果用戶端想要重新內嵌資料，而不想讓重新內嵌的資料如同延遲抵達，例如基於保留目的）。    

## <a name="extent-tagging"></a>範圍標記

在以範圍儲存的中繼資料中，Kusto 支援將多個選擇性*範圍標記*附加至範圍。 範圍標記（或單純*標記*）是與範圍相關聯的字串。 您可以使用[. 顯示範圍](extents-commands.md#show-extents)命令來查看與範圍相關聯的標記，以及[範圍標記（）](../query/extenttagsfunction.md)函數來查看與範圍中的記錄相關聯的標記。
範圍標籤可以用來有效率地描述範圍內所有資料的相關屬性。
例如，您可以在內嵌期間加入範圍標記，以指出正在內嵌的資料來源，稍後使用該標籤。 當兩個或多個範圍被合併時，如果將所產生的範圍標記與所合併之範圍的所有範圍標籤聯集合並，則會在它們的描述資料時，將其關聯的標記合併在一起。

Kusto 會將特殊意義指派給其值具有格式*首碼**尾碼*的所有範圍標籤，其中的*前置*詞為下列其中一個：

* `drop-by:`
* `ingest-by:`

### <a name="drop-by-extent-tags"></a>' drop： ' 範圍標記

開頭為前置詞的標記 **`drop-by:`** 可用於控制要合併的其他範圍; 具有指定標記的範圍 `drop-by:` 可以合併在一起，但不會與其他範圍合併。 這可讓使用者根據其標記發出命令，以捨棄範圍 `drop-by:` ，例如下列命令：

```kusto
.ingest ... with @'{"tags":"[\"drop-by:2016-02-17\"]"}'

.drop extents <| .show table MyTable extents where tags has "drop-by:2016-02-17" 
```

#### <a name="performance-notes"></a>效能注意事項

* `drop-by`不建議使用過度標記。 以上述方式卸載資料的支援是用於不常發生的事件，不是用來取代記錄層級的資料，而且非常依賴以這種方式標記的資料是「龐大」的事實。 嘗試為每一筆記錄或少量記錄提供不同的標記，可能會對效能造成嚴重的影響。
* 如果這類標記不需要在內嵌資料之後的一段時間，建議您卸載[標記](extents-commands.md#drop-extent-tags)。

### <a name="ingest-by-extent-tags"></a>' 內嵌： ' 範圍標記

開頭為前置詞的標記 **`ingest-by:`** 可用於確保資料只會內嵌一次。 使用者可以發出內嵌命令，以防止資料被內嵌（如果已經使用屬性來處理這個特定標記的範圍） `ingest-by:` **`ingestIfNotExists`** 。
和的值 `tags` `ingestIfNotExists` 都是字串陣列，序列化為 JSON。

下列範例只會內嵌資料一次（第二個和第三個命令不會執行任何動作）：

```kusto
.ingest ... with (tags = '["ingest-by:2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]', tags = '["ingest-by:2016-02-17"]')
```

> [!NOTE]
> 在一般情況下，內嵌命令可能會同時包含 `ingest-by:` 標記和 `ingestIfNotExists` 屬性，並設定為相同的值（如上面的第3個命令所示）。

#### <a name="performance-notes"></a>效能注意事項

- `ingest-by`不建議使用超標記。
如果已知管線饋送 Kusto 有資料重複問題，建議您盡可能解決這些問題，然後才將資料內嵌至 Kusto，並 `ingest-by` 僅適用于 Kusto 至內嵌的部分可能會產生重複專案的情況（例如，有可能與已在進行中的內嵌呼叫重迭的重試機制）。 嘗試為 `ingest-by` 每個內嵌呼叫設定唯一標記，可能會對效能造成嚴重的影響。
- 如果這類標記不需要在內嵌資料之後的一段時間，建議您卸載[標記](extents-commands.md#drop-extent-tags)。
